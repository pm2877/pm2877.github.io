---
layout: single
title:  "iOS Notes"
date:   2019-03-22 10:13:06 -0500
categories: Tech
toc: true
toc_label: "On this page"
toc_icon: "list"
---

# iOS Training - Big Nerd Ranch

**Instructor**: Zachary Waldowski (zachary@bignerdranch.com)

{:toc}

## General Notes

1. Xcode comes with an iOS simulator, not emulator . The difference between emulators and simulators is that emulators mimic the software ***and*** hardware environments found on actual devices. Simulators, on the other hand, only mimic the software environment; they otherwise have access to all of the host system's **(the laptop's)** hardware resources such as disk space, memory and processor speed.
2. Main.storyboard --> description of UI in the application.
3. **control + drag to activate layout constraints between 2 views**
4. alt + click --> see data type
5. **To connect views to their references in the code, go to Controller View, and in the connections inspector, connect the variables declared in code to the UI elements.**
6. To create actions for methods, drag the action from connections inspector to the code to create a new action. It's easier to use the Assistant editor to see both the ViewController.swift and the Main.storyboard.
7. Vertical spacing is similar to relative positioning. It is relative to two views.
8. Swift is a statically typed and a strongly typed language.
9. Unlike Android, the app or the activity is not relaunched when the screen is rotated. This is because iOS has separate view heirarchy process and a separate view layout process. Layout constraints are applied during the view layout process.
10. Many iOS frameworks are still written in Objective-C even though we interact with them through Swift.
11. The `@discardableResult` annotation before the `func` keyword in the function definition means that a caller of this function is free to ignore the result of calling this function. 
12. When writing iOS applications, it is important to treat each UIViewController as its own little world. The stuff that has already been implemented in Cocoa Touch will do the heavy lifting.
13. Instead of assigning a value to the property directly, the value is sometimes set using a closure. Using a closure like this allows you to set the value for a variable or constant that requires multiple lines of code, which can be very useful when configuring objects. This makes your code more maintainable because it keeps the property and the code needed to generate the property together.



## MVC

iOS follows Model-View-Controller pattern. In the MVC design pattern, which iOS developers do their best to follow, each class falls into exactly one of the following categories: 

- model: holds data and knows nothing about the UI 
- view: is visible to the user and knows nothing about the model objects 
- controller: keeps the UI and the model objects in sync and controls the flow of the application

![image-20190318104116297](/images/image-20190318104116297.png)



**Sample app code:**

```swift
//
//  ViewController.swift
//  Quiz
//
//  Created by Parth Mehta on 3/18/19.
//  Copyright © 2019 Big Nerd Ranch. All rights reserved.
//

import UIKit

class ViewController: UIViewController {
    
    let questions: [String] = [
        "From what is congnac made?",
        "What is 7 + 7?",
        "What is the capital of Vermont?"
    ]

    let answers: [String] = [
        "Who knows",
        "14",
        "Montepelier"
    ]
    
    var currentQuestionIndex = 0;
    @IBOutlet var questionLabel: UILabel?
    @IBOutlet var answerLabel: UILabel?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let question = questions[currentQuestionIndex]
        questionLabel?.text = question
    }

    @IBAction func onTapShowAction(_ sender: Any) {
        let answer = answers[currentQuestionIndex]
        answerLabel?.text = answer
    }
    
    @IBAction func onnTapNextQuestion(_ sender: Any) {
        answerLabel?.text = "????"
        currentQuestionIndex = (currentQuestionIndex + 1) % questions.count
        
        let question = questions[currentQuestionIndex]
        questionLabel?.text = question
    }
}
```

![image-20190318113932176](/images/image-20190318113932176.png)

Only this much code to create the question answer app!! :D



## Swift Basics

#### Optionals and Optional Binding

- An optional lets you express the possibility that a variable may not store a value at all. The value of an optional will either be an instance of the specified type or nil.
- Allows the developer to indicate that an instance of any data type may be nil. 
- Note that before using the optional variables like normal variables, you must unwrap the optional and address the possibility of it being nil.
- Use 'if let' to check values and conditionally perform logic (optional binding).
- Two ways of unwrapping an optional variable: optional binding and forced unwrapping.
- **Subscripting dictionaries:** Recall that subscripting an array beyond its bounds causes a trap. Dictionaries are different. The result of subscripting a dictionary is an optional: 

```swift
let titles = ["Leader": "Dear Leader", "Commandante": "Commandante", "Brightlord": "Brightlord"]
var optionalTitle: String? = titles["Leader"]
var greeting = "Hello"
if let title = optionalTitle {
    greeting += " \(title)"
} // Note that here, we convert the optional optionalTitle to a String

// greeting += " \(optionalTitle!)" // crash if optionalTitle  == nil
```

#### Collections: Array 

```swift
var bros: [String] = ["Matt","Scott","Josh","Nick"] // could also infer type
bros += ["Brian"] // ["Matt","Scott","Josh","Nick","Brian"]
bros[3] = "Brandon" // ["Matt","Scott","Josh","Brandon","Brian"]
bros.removeAtIndex(4) // ["Matt","Scott","Josh","Brandon"]
```

#### Collections: Dictionary 

```swift
var etBroHome: [String: String] = ["Matt": "GA","Scott": "DC"]
etBroHome["Brian"] = "GA" // ["Matt": "GA","Scott": "DC","Brian: GA"]
if let oldMattSt = etBroHome.updateValue("CA", forKey:"Matt") {
    print("Old state: \(oldMattSt)")
}
```

#### Control Flow: Conditional Statements

'if' executes a set of statements if expression evalutates to true 

```swift
var swiftIsAwesome: Bool = true
if swiftIsAwesome {
    print("Duh")
} else {
    print("Something went wrong.")
}
```

'switch' statements compare a value against a number of cases 

```swift
// Very imp thing to note is the absence of break statements. Swift break statements don't fall through by default. You can however, specify it to fall through. You can't fall through multiple cases though.

let favoriteFood: String = "Cookie Pie"
var comment: String
switch favoriteFood {
    case "Vegetables":
        comment = "Ew"
    case "Fruit":
        comment = "Okay..."
    case let x where x.hasSuffix("Pie"): // this assigns x = favoriteFood first
        comment = "\(x) sounds good!"
    default:
        comment = "Tell me more..."
}
```

#### Control Flow: For-in Loop 

```swift
// Note that there is not manual version of the for-loop. If we need to use a manual version, we can use a while loop.

for index in 1..<5 {
    print(index) // 1 2 3 4
}
for index in 1...5 {
    print(index) // 1 2 3 4 5
}
var things = ["socks","bannana","ennui"]
for word in things {
    print(word)
}
var etBroHome = ["Matt": "GA","Scott": "DC"] // infers type
for (name, state) in etBroHome {
    print(name, state) // (Matt, GA); (Scott, DC)
}
```

#### Functions

```swift
// pay attention to the return type and the external parameter name
func printNumber(number: Int) {
    print(number)
}
printNumber(5) // logs 5 to console

func equalToTen(myNumber number: Int) -> Bool { 
    // myNumber is an explicitly named external parameter
    return number == 10
}
equalToTen(myNumber: 5) // false

func hasMatches(list: [Int], condition: (Int -> Bool)) -> (Bool, Int) {
    var count = 0
    var hasMatch = false
    for item in list {
        if condition(item) {
			count += 1 
        }
    }
    hasMatch = count != 0
    return (hasMatch, count)
}
var numbers = [10, 20, 21, 10]
print("Has matches: \(hasMatches(numbers, condition: equalToTen))") // (true, 2)
```

#### Closures 

```swift
var moreNumbers = [10,3,11,24]
let newNumbers = moreNumbers.map {
    (number) -> Int in   			// in is just a seperator that separates params from 										the function body in closures
    return number % 2 != 0 ? 0 : number * 3
}
print(newNumbers) // [30,0,0,72]
```

#### Structs 

```swift
struct House {
    var hotTubs: Int
    func describeHouse() -> String { return "House has \(hotTubs) hot tubs!" }
}
var myHouse = House(hotTubs: 4)
print(myHouse.describeHouse()) // House has 4 hot tubs!
```

#### Classes 

```swift
class Parent: Person {
    var hasChildren: Bool
    static var hasStaticChildren: Bool 		// class level variable
    init(hasChildren: Bool) {
        // constructor. Note that all inits are functions.
        // You can also have destructors called dinit()
        self.hasChildren = hasChildren
    }
    class func exampleTypeMethod() {
        // class level method
        // like a static method in Java?
    	// stuff here
    }
    func exampleInstanceMethod() {
        // instance level method
    	// stuff here
    }
}
var john = Parent(hasChildren: true)
Parent.exampleTypeMethod()
john.exampleInstanceMethod()

// The way we assign innitialisation values are safer in Swift
class Parent: Person {
    var hasChildren: Bool
    init(name: String, heightInMeters: Double, hasChildren: Bool) {
        self.hasChildren = hasChildren
        super.init(name: name, heightInMeters: heightInMeters)
    }
}
var john = Parent(name: "John", heightInMeters: 1.8, hasChildren: true)
```

**Differences between Classes and Structs in Swift**

- Class instances are shared in memory. 
- **Class instances are copied by reference, struct instances are copied by value,** i.e. Each copy of a struct is a new instance.
- Contents of classes are mutable by all instances, irrespective of whether they are defined as `let ` or `const`, unlike in structs.
- Structs have default initializers, unlike classes. Classes need initializers to be defined by us.

#### Properties

```swift
struct Meal {
    var time: Int
    var duration: Int
}
struct Day {
    let name: String
    var breakFast: Meal
    var intervalBetweenMeals: Int
    var lunch: Meal {
		get {
            let time = breakFast.time + breakFast.duration + intervalBetweenMeals
            let duration = breakFast.duration
            return Meal(time: time, duration: duration)
        }
        set(newLunch) {
            breakFast.time = newLunch.time - intervalBetweenMeals
            breakFast.duration = newLunch.duration
        }
    }
}
let aMeal = Meal(time: 8, duration: 1)
var aDay = Day(name: "Monday", breakFast: aMeal, intervalBetweenMeals: 3)
aDay.lunch // name = Monday; time = 12; duration = 1
```

#### Protocols 

```swift
// Protocols are similar to interfaces in Java and you can conform to multiple protocols (this is how you can achieve multiple inheritance in Swift).
protocol ExampleProtocol {
    mutating func doSomething()
    var aReadonlyIntProperty: Int { get }
    var aReadwriteStringProperty: String { get set }
}
class SomeClass: ExampleProtocol {
    func doSomething 
    { 
        // code here
    }
    // getter for aReadOnlyIntProperty here
    // getter and setter for aReadWriteStringProperty here
}
```

#### Extensions 

```swift
// add custom vars and methods to the basic types in Swift.
// Note the visibility of these extensions is across the entire project.
extension Int: ExampleProtocol {
    var timesFive: Int {
        return self * 5
    }
    mutating func doSomething {
    // code here 
    }
}
5.doSomething
5.timesFive // 25
```

#### Generics 

```swift
func swapTwoValues<T>(inout a: T, inout b: T) { 
	let temporaryA = a
	a = b
    b = temporaryA     
    // (a, b) = (b, a)
}
swapTwoValues(&someInt, &anotherInt)
swapTwoValues(&someString, &anotherString)
protocol RemoveInstance {
    typealias ItemType
    mutating func removeInstance(item: ItemType)
}
```



## Views Basics

#### Views

Views are objects that are visible to the user, like buttons, text fields, and sliders. View objects make up an application’s UI. A view: 

- is an instance of UIView or one of its subclasses 
- knows how to draw itself 
- can handle events, like touches 
- exists within a hierarchy of views whose root is the application’s window 

#### The View Hierarchy 

Every application has a single instance of UIWindow that serves as the container for all the views in the application. UIWindow is a subclass of UIView, so the window is itself a view. The window is created when the application launches. Once the window is created, other views can be added to it. 

![image-20190318134431322](/images/image-20190318134431322.png)

#### Views and Frames

When the application is launched, the view for the initial view controller is added to the root-level window. This view controller is represented by the ViewController class defined in `ViewController.swift`.

#### Creating a view programmatically. 

```swift
let rect = CGRect(x: 0, y: 0, width: 20, height: 20)
let squareView = UIView(frame: rect)
someOtherView.addSubview(squareView)
```

> **<u>Note</u>:** that these values are in points, not pixels. If the values were in pixels, then they would not be consistent across displays of different resolutions (i.e., Retina versus non-Retina). A point is a relative unit of a measure; it will be a different number of pixels depending on how many pixels are in the display. Sizes, positions, lines, and curves are always described in points to allow for differences in display resolution.

#### Frame Vs. Bounds

Frame boundaries are the boundaries of the view, from where to where the view is displayed. Bounds, on the other hand are the limits of the content of the view. Think about scrolling in a maps view. 

The alignment rectangle is very similar to the frame. In fact, these two rectangles are often the same. Whereas the frame encompasses the entire view, the alignment rectangle only encompasses the content that you wish to use for alignment purposes.

You cannot define a view’s alignment rectangle directly. You do not have enough information (like screen size) to do that. Instead, you provide a set of constraints. Taken together, these constraints enable the system to determine the layout attributes, and thus the alignment rectangle, for each view in the view hierarchy.

![image-20190318134658420](/images/image-20190318134658420.png)



#### What other information does a view have? 

```swift
// Hierarchy (Painter's method):
var window: UIWindow? { get }
var superview: UIView? { get }
var subviews: [UIView] { get }
func addSubview(_ view: UIView)
func insertSubview(_ view: UIView, at index: Int)

// Location of view:
var frame: CGRect
var bounds: CGRect

// Display properties:
var backgroundColor: UIColor?
var hidden: Bool
var alpha: CGFloat
```



#### Auto Layout

Auto Layout is a crucial technology for every iOS developer. It helps you create flexible layouts that work across a range of devices and interface sizes. It also takes a lot of practice to master.

![image-20190318135555143](/images/image-20190318135555143.png)



#### Constraints Menu

In addition to using cntrl+drag to create relative positioning between 2 views, we also define constraints to the view.

![image-20190318160506008](/images/image-20190318160506008.png)

![image-20190318163122326](/images/image-20190318163122326.png)

If a view does not have any siblings in the specified direction, then the nearest neighbor is its superview, also known as its container.

#### Align Menu

![image-20190318160547006](/images/image-20190318160547006.png)



## View Controller

A view controller is an instance of a subclass of UIViewController. A view controller manages a view hierarchy. It is responsible for creating view objects that make up the hierarchy and for handling events associated with the view objects in its hierarchy.

Just think of a view controller as one view hierarchy. When an app switches between view controllers, it just means that it is switching between two different view heirarchies.

#### The View of a View Controller 

As subclasses of UIViewController, all view controllers inherit an important property:

```
var view: UIView!
```

This property points to a UIView instance that is the root of the view controller’s view hierarchy. When the root  view of a view controller is added as a subview of the window, the view controller’s entire view hierarchy is added .

![image-20190319112500365](/images/image-20190319112500365.png)

A view controller’s view is not created until it needs to appear on the screen. This optimization is called lazy loading, and it can conserve memory and improve performance. 

There are two ways that a view controller can create its view hierarchy: 

- in Interface Builder, by using an interface file such as a storyboard 
- programmatically, by overriding the UIViewController method loadView() 

> **<u>NOTE</u>**: Although a storyboard can have many view controllers, each storyboard file has exactly one **initial view controller**. The initial view controller acts as an entry point into the storyboard. 

#### How does UIWindow handle the view controllers?

UIWindow has a rootViewController property. When a view controller is set as the window’s rootViewController, that view controller’s view gets added to the window’s view hierarchy. When this property is set, any existing subviews on the window are removed and the view controller’s view gets added to the window with the appropriate Auto Layout constraints. 

**Each application has one main interface, a reference to a storyboard. When the application launches, the initial view controller for the main interface gets set as the rootViewController of the window.** 

The main interface for an application is set in the project settings. In the General tab of the project settings, find the Deployment Info section. Here you will see the Main Interface setting. If it is set to Main, for example, it corresponds to Main.storyboard. 

#### Tab Bar Controllers

UITabBarController keeps an array of view controllers. It also maintains a tab bar at the bottom of the screen with a tab for each view controller in its array. Tapping on a tab results in the presentation of the view of the view controller associated with that tab.

UITabBarController is itself a subclass of UIViewController. A UITabBarController’s view is a UIView with two
primary subviews: the tab bar and the view of the selected view controller 

![image-20190319114632381](/images/image-20190319114632381.png)

#### Tab bar items 

Each tab on the tab bar can display a title and an image, and each view controller maintains a tabBarItem property for this purpose. When a view controller is contained by a UITabBarController, its tab bar item appears in the tab bar.

The order of the tabs is determined by the order of the view controllers within the tab bar controller’s viewControllers array. 

#### Accessing subviews 

Often, you will want to do some extra initialization or configuration of subviews defined in Interface Builder before they appear to the user. So where can you access a subview? There are two main options, depending on what you need to do. The first option is the `viewDidLoad()` method. This method
 is called after the view controller’s interface file is loaded, at which point all of the view controller’s outlets will reference the appropriate objects. The second option is another UIViewController method, `viewWillAppear`. This method is called just before a view controller’s view is added to the window. 

Which should you choose? Override viewDidLoad() if the configuration only needs to be done once during the run of the app. Override `viewWillAppear` if you need the configuration to be done each time the view controller’s view appears onscreen. 

#### Interacting with View Controllers and Their Views 

Let’s look at some methods that are called during the lifecycle of a view controller and its view. Some of these methods you have already seen, and some are new. 

- **init(coder:)** is the initializer for UIViewController instances created from a storyboard.
   When a view controller instance is created from a storyboard, its init(coder:) gets called once.

- **init(nibName:bundle:)** is the designated initializer for UIViewController. 

  When a view controller instance is created without the use of a storyboard, its init(nibName:bundle:) gets called once. Note that in some apps, you may end up creating several instances of the same view controller class. This method will get called once on each view controller as it is created. 

- **loadView()** is overridden to create a view controller’s view programmatically. 

- **viewDidLoad()** is overridden to configure views created by loading an interface file. This method gets called after the view of a view controller is created. 

- **viewWillAppear(_:)** is overridden to configure views created by loading an interface file. 

  This method and **viewDidAppear(_:)** get called every time your view controller is moved onscreen. **viewWillDisappear(_:)** and **viewDidDisappear(_:)** get called every time your view controller is moved offscreen. 

#### Programmatic View Composition 

UIView has an instance method **addSubview(_:)** which let's you add a child view to its subviews collec4on. Other useful methods: 

- **bringSubview(toFront:)**
- **sendSubview(toBack:)** 
- **removeFromSuperview()** 

> **<u>NOTE</u>**: When using bringSubview and sendSubview, remember that the view to be brought back or sent forward is also already loaded (no lazy loading here).

#### Programmatic Constraints

> **<u>Note</u>**: 
>
> 1. Constraints need to be added to the most recent common ancestor for the views associated with the constraint.
>
> 2. Creating and activating constraints are two different steps.
>

```swift
let leadingAlignConstraint =
    view1.leadingAnchor.constraint(equalTo: view2.leadingAnchor)
leadingAlignConstraint.isActive = true
```

![image-20190319123127198](/images/image-20190319123127198.png)

##### Layout Margin Guides

Every view has a layoutMargins property that denotes the default spacing to use when laying out content. This property is an instance of UIEdgeInsets, which you can think of as a type of frame. When adding constraints, you will use the layoutMarginsGuide, which exposes anchors that are tied to the edges of the layoutMargins. 

The primary advantage of using the margins is that the margins can change depending on the device type (iPad or iPhone) as well as the size of the device. Using the margins will give you content that looks good on any device. 

```swift
let margins = view.layoutMarginsGuide
let constraint =
    someView.leadingAnchor.constraint(equalTo: margins.leadingAnchor)
constraint.isActive = true
```

##### Layout Safe Area Guides

View instances have a property to assist with layout content: the safeAreaLayoutGuide. This layout guide represents the rectangular extent to which the a view will be visible on screen. Using safeAreaLayoutGuide will allow your content to not underlap the status bar at the top of the screen or the tab bar at the bottom of the screen. 

Layout guides like safeAreaLayoutGuide expose anchors that you can use to add constraints, such as : topAnchor, bottomAnchor, heightAnchor and widthAnchor. Because you want the segmented control to be under the status bar and sensor housing, you will constrain the top anchor of the safe area layout guide to the top anchor of the segmented control. 

```swift
let constraint =
    someView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor,constant: 20)
constraint.isActive = true
```

##### Controls

```swift
func loadView() {
    ...
    let button = UIButton(type: .system)
    // this is similar to what we do in the interface builder by dragging and dropping.
    button.addTarget(self,
           action: #selector(buttonTapped(_:)),
           for: .touchUpInside)
    ...
}

func buttonTapped(_ sender: UIButton) {
    // do something
}
```

##### Control Events

![image-20190319124023164](/images/image-20190319124023164.png)

#### Q. When exactly is the loadview() method called?

When a view controller is created, its view property is nil. If a view controller is asked for its view and its view is nil, then the loadView() method is called.

> **<u>NOTE</u>**:  **Apple recommends that you create and constrain your views in Interface Builder whenever possible.** However, if your views are created in code, then you will need to constrain them programmatically. 

> **<u>NOTE</u>**: Every view has an autoresizing mask. By default, iOS creates constraints that match the autoresizing mask and adds them to the view. These translated constraints will often conflict with explicit constraints in the layout and cause an unsatisfiable constraints problem. The fix is to turn off this default translation by setting the property translatesAutoresizingMaskIntoConstraints to false.



## Text Input & Delegation

**Delegation** is an object-oriented approach to callbacks. A callback is a function that is supplied in advance of an event and is called every time the event occurs. Some objects need to make a callback for more than one event. For instance, the text field needs to “callback” when the user enters text as well as when the user presses the Return key.

However, there is no built-in way for two (or more) callback functions to coordinate and share information. This is the problem addressed by delegation – you supply a single delegate to receive all of the event-related callbacks for a particular object. This delegate object can then store, manipulate, act on, and relay the information from the callbacks as it sees fit.

![image-20190319142000565](/images/image-20190319142000565.png)

```swift
textField.delegate = self // Our controller
// In our controller
func textFieldShouldReturn(_ textField: UITextField) -> Bool {
    print(textField.text)
    // dismisses the keyboard and gives up the first responder status
    textField.resignFirstResponder() 
    return true // whether to perform the default action or not? default action is nothing  in this particular case.
} 
```

![image-20190319142952879](/images/image-20190319142952879.png)

#### Conforming to this Protocol (it's just like an interface in Java)

```swift
class MyViewController: UIViewController, UITextFieldDelegate {
}
```

> **<u>NOTE</u>**: When the text field is tapped, the method becomeFirstResponder() is called on it. This is the method
> that, among other things, causes the keyboard to appear. To dismiss the keyboard, you call the method
> resignFirstResponder() on the text field.

> **<u>NOTE</u>**: A property observer, is a chunk of code that gets called whenever a property’s value changes. A property observer is declared using curly braces immediately after the property declaration. Inside the braces, you declare your observer using either willSet or didSet, depending on whether you want to be notified immediately before or immediately after the property value changes, respectively. Note that property observers are not triggered when the property value is changed from within an initializer.



## Internalization and Localization

Internationalization is making sure your native cultural information (like language, currency, date format, number format, etc.) is not hardcoded into your application. Localization is the process of providing the appropriate data in your application based on the user’s Language and Region Format settings.

> **<u>NOTE</u>**: Locale knows everything about local customs.

![image-20190319151559307](/images/image-20190319151559307.png)

![image-20190319151704807](/images/image-20190319151704807.png)

#### Some formatters to keep in Mind

- Date Formatters
- NumberFormatter
- DateComponentsFormatter
- DateIntervalFormatter
- MassFormatter
- EnergyFormatter
- LengthFormatter
- Address Formatter

When internationalizing, you ask the instance of Locale questions. But the Locale only has a few region-specific variables. This is where localization – creating application-specific substitutions for different region and language settings – comes into play. Localization usually involves either generating multiple copies of resources (like images, sounds, and interface files) for different regions and languages or creating and accessing strings tables to translate text into different languages.

When you build a target in Xcode, an application bundle is created. All of the resources that you added to the target in Xcode are copied into this bundle along with the executable itself. This bundle is represented at runtime by an instance of Bundle known as the main bundle. Many classes work with the Bundle to load resources.

Localizing a resource puts another copy of the resource in the application bundle. These resources are organized into language-specific directories, known as lproj directories. Each one of these directories is the name of the localization suffixed with lproj. For example, the American English localization is en_US, where en is the English language code and US is the United States of America region code, so the directory for American English resources is en_US.lproj. (The region can be omitted if you do not need to make regional distinctions in your resource files.) These language and region codes are standard on all platforms, not just iOS.

When a bundle is asked for the path of a resource file, it first looks at the root level of the bundle for a file of that name. If it does not find one, it looks at the locale and language settings of the device, finds the appropriate lproj directory, and looks for the file there. Thus, just by localizing resource files, your application will automatically load the correct file. 

One option for localizing resource files is to create separate storyboard files and manually edit each string in each file. However, this approach does not scale well if you are planning multiple localizations. What happens when you add a new label or button to your localized storyboard? You have to add this view to the storyboard for every language. Not fun. 

To simplify the process of localizing interface files, Xcode has a feature called base internationalization. Base internationalization creates the Base.lproj directory, which contains the main interface files. Localizing individual interface files can then be done by creating just the Localizable.strings files. It is still possible to create the full interface files, in case localization cannot be done by changing strings alone. 

#### NSLocalizedString and strings tables 

In many places in your applications, you create String instances dynamically or display string literals to the user. To display translated versions of these strings, you must create a strings table. A strings table is a file containing a list of key-value pairs for all of the strings that your application uses and their associated translations. It is a resource file that you add to your application, but you do not need to do a lot of work to get data from it. 



## Table Views

As a view object, a UITableView does not handle application logic or data. When using a UITableView, you must consider what else is necessary to get the table working in your application: 

- A UITableView typically needs a view controller to handle its appearance on the screen. 
- A UITableView needs a data source. A UITableView asks its data source for the number of rows to display, the data to be shown in those rows, and other tidbits that make a UITableView a useful UI. Without a data source, a table view is just an empty container. The dataSource for a UITableView can be any type of object as long as it conforms to the UITableViewDataSource protocol. 
- A UITableView typically needs a delegate that can inform other objects of events involving the UITableView. The delegate can be any object as long as it conforms to the UITableViewDelegate protocol. 

An instance of the class UITableViewController can fill all three roles: view controller, data source, and delegate. 

UITableViewController is a subclass of UIViewController and therefore has a view. A UITableViewController’s view is always an instance of UITableView, and the UITableViewController handles the preparation and presentation of the UITableView. 

When a UITableViewController creates its view, the dataSource and delegate properties of the UITableView are automatically set to point at the UITableViewController.

![image-20190320102625485](/images/image-20190320102625485.png) 

#### Custom Initializers for classes

Classes can have two kinds of initializers: **designated initializers and convenience initializers.** 

**A designated initializer** is a primary initializer for the class. Every class has at least one designated initializer. A designated initializer ensures that all properties in the class have a value. Once it ensures that, a designated initializer calls a designated initializer on its superclass (if it has one). When you implement your own custom initializer, you lose the free initializer – init() – that classes have. The free initializer is useful when all of your class’s properties have default values and you do not need to do additional work to create the new instance. 

Every class must have at least one designated initializer, but **convenience initializers** are optional. You can think of convenience initializers as helpers. A convenience initializer always calls another initializer on the same class. Convenience initializers are indicated by the convenience keyword before the initializer name. 

Convenience initializers must call another initializer on the same type, whereas designated initializers must call a designated initializer on its superclass.

#### Dependency Inversion Principle ---> V.IMP

- The essential goal of this principle is to decouple objects in an application by inverting certain dependencies between them. This results in more robust and maintainable code. 

- The dependency inversion principle states that:

1. High-level objects should not depend on low-level objects. Both should depend on abstractions. 
2. Abstractions should not depend on details. Details should depend on abstractions. 

**<u>Example</u>** - The abstraction required by the dependency inversion principle in LootLogger is the concept of a “store.” A store is a lower-level object that retrieves and saves Item instances through details that are only known to that class. ItemsViewController is a higher-level object that only knows that it will be provided with a utility object (the store) from which it can obtain a list of Item instances and to which it can pass new or updated Item instances to be stored persistently. This results in a decoupling because ItemsViewController is not dependent on ItemStore. In fact, as long as the store abstraction is respected, ItemStore could be replaced by another object that fetches Item instances differently (such as by using a web service) without any changes to ItemsViewController. 

- A common pattern used when implementing the dependency inversion principle is **dependency injection**. In its simplest form, higher-level objects do not assume which lower-level objects they need to use. Instead, those are passed to them through an initializer or property. 
- In our implementation of ItemsViewController, we used injection through a property to give it a store. 

#### Data Source Methods

When a UITableView wants to know what to display, it calls methods from the set of methods declared in the UITableViewDataSource protocol.

#### UITableViewCells

- Each row of a table view is a view. These views are instances of UITableViewCell.
- A cell itself has one subview – its contentView. The contentView is the superview for the content of the cell. The cell may also have an accessory view. 
- The accessory view shows an action-oriented icon, such as a checkmark, a disclosure icon, or an information button. These icons are accessed through predefined constants for the appearance of the accessory view. The default is UITableViewCellAccessoryType.none.
- The real meat of a UITableViewCell is the contentView, which has three subviews of its own. Two of those subviews are UILabel instances that are properties of UITableViewCell named textLabel and detailTextLabel. The third subview is a UIImageView called imageView. In this chapter, you will use textLabel and detailTextLabel. 

![image-20190320110245577](/images/image-20190320110245577.png)

#### Reusing UITableViewCells 

- iOS devices have a limited amount of memory. If you were displaying a list with thousands of entries in a UITableView, you would have thousands of instances of UITableViewCell. Most of these cells would take up memory needlessly. After all, if the user cannot see a cell onscreen, then there is no reason for that cell to have a claim on memory. 
- To conserve memory and improve performance, you can reuse table view cells. When the user scrolls the table, some cells move offscreen. Offscreen cells are put into a pool of cells available for reuse. Then, instead of creating a brand new cell for every request, the data source first checks the pool. If there is an unused cell, the data source configures it with new data and returns it to the table view.
- There is one problem to be aware of: Sometimes a UITableView has different types of cells. Occasionally, you subclass UITableViewCell to create a special look or behavior. However, different subclasses floating around the pool of reusable cells create the possibility of getting back a cell of the wrong type. You must be sure of the type of the cell returned so that you can be sure of what properties and methods it has. 
- Note that you do not care about getting any specific cell out of the pool because you are going to change the cell content anyway. What you need is a cell of a specific type. The good news is that every cell has a reuseIdentifier property of type String. When a data source asks the table view for a reusable cell, it passes a string and says, “I need a cell with this reuse identifier.” By convention, the reuse identifier is typically the name of the cell class. 
- To reuse cells, you need to register either a prototype cell or a class with the table view for a specific reuse identifier. The reuse identifier is an arbitrary string.
- The method `dequeueReusableCell(withIdentifier:for:)` will check the pool, or queue, of cells to see whether a cell with the correct reuse identifier already exists. If so, it will “dequeue” that cell. **If there is not an existing cell, a new cell will be created and returned.**

#### Editing Table Views 

One of the great feature of table views is their built-in support for editing. This includes inserting new rows, deleting existing rows, and rearranging rows. In this section, you will add in support for all three of those features to LootLogger. 

##### Editing Mode 

UITableView has an editing property, and when this property is set to true, the UITableView enters editing mode. Once the table view is in editing mode, the rows of the table can be manipulated by the user. Depending on how the table view is configured, the user can change the order of the rows, add rows, or remove rows. (Editing mode does not allow the user to edit the content of a row.) 

![image-20190320112411286](/images/image-20190320112411286.png)

#####  Adding and Deleting Items

Remember that the role of a view object is to present model objects to the user; updating views without updating the model objects is not very useful.



#### Design Patterns

The consistent use of design patterns throughout the development process reduces the mental overhead in solving a problem so you can create complex applications more easily and rapidly. Here are some of the design patterns that Apple is very consistent with:

- Delegation: One object delegates certain responsibilities to another object. We used delegation with the UITextField to be informed when the contents of the text field change. 
- Data source: A data source is similar to a delegate, but instead of reacting to another object, a data source is responsible for providing data to another object when requested. We used the data source pattern with table views: Each table view has a data source that is responsible for, at a minimum, telling the table view how many rows to display and which cell it should display at each index path. 
- Model-View-Controller: Each object in your applications fulfills one of three roles. Model objects are the data. Views display the UI. Controllers provide the glue that ties the models and views together. 
- Target-action pairs: One object calls a method on another object when a specific event occurs. The target is the object that has a method called on it, and the action is the method being called. For example, we used target- action pairs with buttons: When a touch event occurs, a method will be called on another object (often a view controller). 



## Subclassing UITableViewCell 

A UITableView displays a list of UITableViewCell objects. For many applications, the basic cell with its textLabel, detailTextLabel, and imageView is sufficient. However, when you need a cell with more detail or a different layout, you subclass UITableViewCell. 

#### Customizing the Cell

- You customize the appearance of UITableViewCell subclasses by adding subviews to its contentView. Adding subviews to the contentView instead of directly to the cell itself is important because the cell will resize the contentView inside it at certain times. 
- For example, when a table view enters editing mode, the contentView resizes itself to make room for the editing controls. If you added subviews directly to the UITableViewCell, the editing controls would obscure the subviews. The cell cannot adjust its size when entering edit mode (it must remain the width of the table view), but the contentView can and does.

![image-20190320120018562](/images/image-20190320120018562.png)



#### Dynamic Type 

Creating an interface that appeals to everyone can be daunting. Some people prefer more compact interfaces so they can see more information at once. Others might want to be able to easily see information at a glance, or perhaps they have poor eyesight. In short: People have different needs. Good developers strive to make apps that meet those needs. 

Dynamic Type is a technology that helps realize this goal by providing specifically designed text styles that are optimized for legibility. Users can select one of seven preferred text sizes from within Apple’s Settings application (plus a few additional larger sizes from within the Accessibility section), and apps that support Dynamic Type will have their fonts scaled appropriately.

The Dynamic Type system is centered around text styles. When a font is requested for a given text style, the system will consider the user’s preferred text size in association with the text style to return an appropriately configured font.  

![image-20190320123003161](/images/image-20190320123003161.png)

#### Responding to user changes

When the user changes the preferred text size and returns to the application, the table view will get reloaded. Unfortunately, the labels will not know about the new preferred text size. To fix this, you need to have the labels automatically adjust to content size changes. 

Open Main.storyboard and select all three ItemCell labels. Open the attributes inspector, and check the box for **Automatically Adjusts Font**

##### Bad Cell Constraints

![image-20190320114956174](/images/image-20190320114956174.png)

Since there are are no vertical constraints, the label will be centered with height 0 and would thus, be invisible.

##### Better Cell constraints

![image-20190320115129303](/images/image-20190320115129303.png)



## Stack Views

Auto Layout can be used to create flexible interfaces that scale across device types and sizes. Auto Layout is a very powerful technology, but with that power comes complexity. Laying out an interface well often needs a lot of constraints, and it can be difficult to create dynamic interfaces due to the need to constantly add and remove constraints.

Interfaces that have a linear layout are great candidates for using a stack view. A stack view is an instance of
UIStackView that allows you to create a vertical or horizontal layout that is easy to lay out and manages most of the constraints that you would typically have to manage yourself. Perhaps best of all, you are able to nest stack views within other stack views, which allows you to create truly amazing interfaces in a fraction of the time.

- Nesting stack views is very common when creating more complex layouts 
- **A stack view's "arranged views" are a subset of its "subviews"**  --> because views may be hidden.
- Can dynamically add/remove views in a stack view
- Can dynamically change any of the stack views properties 



#### Properties of StackView

![image-20190320145501757](/images/image-20190320145501757.png)

![image-20190320145526390](/images/image-20190320145526390.png)

#### Hiding Views inside Stackview

```swift
class ViewController: UIViewController {
    @IBAction func hideViewTapped(_ sender: UIButton) {
        UIView.animate(withDuration: 1.0) {
            sender.superview?.isHidden = true
        }
    }
}
```

#### Implicit Constraints

A view has one of these priorities for each axis: 

- horizontal content hugging priority 
- vertical content hugging priority 
- horizontal content compression resistance priority 
- vertical content compression resistance priority 

##### Content hugging priorities 

The content hugging priority is like a rubber band that is placed around a view. The rubber band makes the view not want to be bigger than its intrinsic content size in that dimension. Each priority is associated with a value from 0 to 1000. A value of 1000 means that a view cannot get bigger than its intrinsic content size on that dimension. 

##### Content compression resistance priorities 

The content compression resistance priorities determine how much a view resists getting smaller than its intrinsic content size.  



## Segues 

- Most iOS applications have a number of view controllers that users navigate between. Storyboards allow you to set up these interactions as segues without having to write code. 
- A segue moves another view controller’s view onto the screen and is represented by an instance of UIStoryboardSegue. 
- Each segue has a style, an action item, and an identifier. 
- The style of a segue determines how the view controller will be presented. 
- The action item is the view object in the storyboard file that triggers the segue, like a button, a table view cell, or some other UIControl. 
- The identifier is used to programmatically access the segue. This is useful when you want to trigger a segue that does not come from an action item, like a shake or some other interface element that cannot be set up in the storyboard file. 

#### Passing Data Around 

Whenever a segue is triggered, the prepare(for:sender:) method is called on the view controller initiating the segue. This method has two arguments: the UIStoryboardSegue, which gives you information about which segue is happening, and the sender, which is the object that triggered the segue (a UITableViewCell or a UIButton, for example). 

The UIStoryboardSegue gives you three pieces of information: the source view controller (where the segue originates), the destination view controller (where the segue ends), and the identifier of the segue. The identifier lets you differentiate segues. Let’s give the segue a useful identifier. 



## UINavigationController 

- A UINavigationController maintains an array of view controllers presenting related information in a stack. When a UIViewController is on top of the stack, its view is visible. 

- When you initialize an instance of UINavigationController, you give it a UIViewController. This UIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack.

  > **<u>Note</u>**: While this view controller is referred to as the navigation controller’s “root view controller,” **UINavigationController does not have a rootViewController property**.

- More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s **topViewController** property keeps a reference to the view controller at the top of the stack. 

- When a view controller is pushed onto the stack, its view slides onscreen from the right. When the stack is popped (i.e., the last item is removed), the top view controller is removed from the stack and its view slides off to the right, exposing the view of the next view controller on the stack, which becomes the top view controller.

- **The view of the topViewController is what the user sees.**

- UINavigationController is a subclass of UIViewController, so it has a view of its own. Its view always has two subviews: a UINavigationBar and the view of topViewController

![image-20190320151348721](/images/image-20190320151348721.png)

#### Appearing and Disappearing Views 

- Whenever a UINavigationController is about to swap views, it calls two methods: viewWillDisappear(_:) and viewWillAppear(_:). The UIViewController that is about to be popped off the stack has viewWillDisappear(_:) called. The UIViewController that will then be on top of the stack has viewWillAppear(_:) called on it. 
- To hold on to changes in the data, when a DetailViewController is popped off the stack you will set the
   properties of its item to the contents of the text fields. When implementing these methods for views appearing and disappearing, **it is important to call the superclass’s implementation – it might have some work to do and needs to be given the chance to do it.** 

#### First Responder Status

- For the shake and keyboard events, for example, there is no event location within your view hierarchy to determine which view will receive the event, so another mechanism must be used. This mechanism is the **first responder status**. Many views and controls can be a first responder within your view hierarchy – but only one at a time. Think of it as a flag that can be passed among views. Whichever view holds the flag will receive the shake or keyboard event. 
- Instances of UITextField and UITextView have an uncommon response to touch events. When touched, a text field or a text view becomes the first responder, which in turn triggers the system to put the keyboard onscreen and send the keyboard events to the text field or view. The keyboard and the text field or view have no direct connection, but they work together through the first responder status. 
- This is a neat way to ensure that the keyboard input is delivered to the correct text field. The concept of a first responder is part of the broader topic of event handling in Cocoa Touch programming that includes the UIResponder class and the responder chain. *<u>You can visit Apple’s Event Handling Guide for iOS for more information.</u>* 

#### UINavigationBar

- Every UIViewController has a navigationItem property of type UINavigationItem. However, unlike
  UINavigationBar, UINavigationItem is not a subclass of UIView, so it cannot appear on the screen. 

- Instead, the navigation item supplies the navigation bar with the content it needs to draw. When a UIViewController comes to the top of a UINavigationController’s stack, the UINavigationBar uses the UIViewController’s navigationItem to configure itself.

- By default, a UINavigationItem is empty. At the most basic level, a UINavigationItem has a simple title string. When a UIViewController is moved to the top of the navigation stack and its navigationItem has a valid string for its title property, the navigation bar will display that string.

  ![image-20190320160559137](/images/image-20190320160559137.png)

- A navigation item can hold more than just a title string. There are three customizable areas for each UINavigationItem: a leftBarButtonItem, a rightBarButtonItem, and a titleView. The left and right bar button items are references to instances of UIBarButtonItem, which contain the information for a button that can only be displayed on a UINavigationBar or a UIToolbar. 

- Recall that UINavigationItem is not a subclass of UIView. Instead, UINavigationItem encapsulates information that UINavigationBar uses to configure itself. Similarly, UIBarButtonItem is not a view, but holds the information about how a single button on the UINavigationBar should be displayed. (A UIToolbar also uses instances of UIBarButtonItem to configure itself.) 

- The third customizable area of a UINavigationItem is its titleView. You can either use a basic string as the title or have a subclass of UIView sit in the center of the navigation item. You cannot have both. If it suits the context of a specific view controller to have a custom view (like a segmented control or a text field, for example), you would set the titleView of the navigation item to that custom view. Typically, however, a title string is sufficient. 

  ![image-20190320161206584](/images/image-20190320161206584.png)

  When you initialize an instance of UINavigationController, you give it a UIViewController. This
  UIViewController is added to the navigation controller’s viewControllers array and becomes the navigation controller’s root view controller. The root view controller is always on the bottom of the stack. 

  > **<u>Note</u>**: While this view controller is referred to as the navigation controller’s “root view controller,” **UINavigationController does not have a rootViewController property.**

  More view controllers can be pushed on top of theUINavigationController’s stack while the application is running. These view controllers are added to the end of the viewControllers array that corresponds to the top of the stack. UINavigationController’s topViewController property keeps a reference to the view controller at the top of the stack.

## Saving, Loading and Error Handling

> **<u>NOTE</u>**: *Saving and loading “data” almost always means saving and loading model objects.*

- To save and load model objects to and from the disk, we need to make them of type *codable*.

- Types whose instances need to be codable conform to the **Encodable** and **Decodable** protocols and implement their two required methods, **encode(to:)** and **init(from:)**, respectively.

```swift
protocol Decodable {
    init(from decoder: Decoder) throws
}
protocol Encodable {
    func encode(to encoder: Encoder) throws
}
```

Although your types can conform to just one of these protocols, it's common for types to conform to both. Apple has a type alias for types that conform to both protocols called Codable. 

```swift
typealias Codable = Decodable & Encodable 
```

#### Property Lists 

- A property list is a representation of some data that can be saved to disk and read back in at a later point. Property lists can represent hierarchies of data and so are a great tool for saving and loading lightweight object graphs. 

- Under the hood, property list data can be represented by a number of formats, they are frequently represented using an XML or binary format.
- Property lists can hold the following types: Array, Dictionary, String, Data, Date, Int, Float, and Bool. As long as a given type is composed of those types, or a hierarchy of those types, then it can be represented as a property list.



```swift
func saveChanges() -> Bool {    
    let encoder = PropertyListEncoder()
    // You will have an error on the next line, for not catching errors.
    let data = encoder.encode(allItems)
    return false
}
```

#### Error Handling

- Optionals provide a simple way to represent failure when you do not care about the reason for failure. When you need to know why something failed, an optional will not provide enough information.
- If a method could generate an error, its method signature needs to indicate this using the throws keyword. Error throwing and exception hanndling is 'opt-in' in Swift.
- The throws keyword indicates that this method could throw an error. (If you are familiar with throwing exception in other languages, Swift’s error handling is not the same as throwing exception.) 
- By using this keyword, the compiler ensures that anyone who uses this method knows that this method can throw an error – and, more importantly, that the caller also handles any potential errors.
- To call a method that can throw, you use a do-catch statement. Within the do block, you annotate any methods that might throw an error using the try keyword to reinforce the idea that the call might fail.
- If a method does throw an error, then the program immediately exits the do block; no further code in the do block is executed. At that point, the error is passed to the catch block for it to be handled in some way.

```swift
func deleteImage(at imageURL: URL) {
    let fileManager = FileManager.default
    do {
        // need try for every statement that can fail
        try fileManager.removeItem(at: imageURL) // this method might throw an error
} catch { 
        print("Error removing image: \(error)")
    }
} 
```

#### Application Sandbox

Every iOS application has its own application sandbox. An application sandbox is a directory on the filesystem that is barricaded from the rest of the filesystem. Your application must stay in its sandbox, and no other application can access its sandbox.

![image-20190321105354677](/images/image-20190321105354677.png)

#### Constructing a file URL 

The instances of our model objects will be saved to a single file in the Documents directory. The store will handle writing to and reading from that file. To do this, the store needs to construct a URL to this file. 

```swift
// Adding a URL where the items will be saved to
var allItems = [Item]()
let itemArchiveURL: URL = {
    let documentsDirectories =
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
    let documentDirectory = documentsDirectories.first!
    return documentDirectory.appendingPathComponent("items.plist")
}()
```

- The method urls(for:in:) searches the filesystem for a URL that meets the criteria given by the arguments.

- In iOS, the last argument is always the same. (This method is borrowed from macOS, where there are significantly more options.) The first argument is a SearchPathDirectory enumeration that specifies the directory in the sandbox you want the URL for. For example, searching for .cachesDirectory will return the Caches directory in the application’s sandbox.

#### Persisting the Items 

You have a place to save data on the filesystem and a model object that can be saved to the filesystem. How do you kick off the saving and loading processes, and when do you do it? 

```swift
// Writing data to disk
func saveChanges() -> Bool {
	print("Saving items to: \(itemArchiveURL)")
    do {
        let encoder = PropertyListEncoder()
        let data = try encoder.encode(allItems) 
        try data.write(to: itemArchiveURL) 
        return true 	
    } catch let encodingError {
        print("Error encoding allItems: \(encodingError)")
        return false 
    } 
} 
```

> **<u>NOTE</u>**: When the user leaves the application (often by swiping up on the Home indicator), the message
> applicationDidEnterBackground(_:) is sent to the AppDelegate.

#### Loading the Items

```swift
init() { 
    do { 
        let data = try Data(contentsOf: itemArchiveURL)
        let unarchiver = PropertyListDecoder()
        let items = try unarchiver.decode([Item].self, from: data)
        allItems =  items
	} catch { 
        print("Error reading in saved items: \(error)")
    }
} 
```



## Application States and Transitions

When an application is not running, it is in the **not running state** and it does not execute any code or have any memory reserved in RAM. 

After the user launches an application, it enters the **active state**. When in the active state, an application’s interface is on the screen, it is accepting events, and its code is handling those events. 

While in the active state, an application can be temporarily interrupted by a system event like an SMS message, push notification, phone call, or alarm. An overlay will appear on top of your application to handle this event, and the application enters the **inactive state**. In the inactive state, an application is visible behind the overlay and is executing code, but it is not receiving events. Applications typically spend very little time in the inactive state. You can force an active application into the inactive state by pressing the Lock button at the top of the device. The application will stay inactive until the device is unlocked. 

When the user swipes up on the Home indicator or switches to another application in some other way, the application enters the **background state**. (Actually, it spends a brief moment in the inactive state before transitioning to the background state.) In the background state, an application’s interface is not visible or receiving events, but it can still execute code. By default, an application that enters the background state has about 10 seconds before it enters the **suspended state**. Your application should not rely on this number; instead, it should save user data and release any shared resources as quickly as possible. 

**An application in the suspended state cannot execute code.** You cannot see its interface, and any resources it does not need while suspended are destroyed. A suspended application is essentially flash-frozen and can be quickly thawed when the user relaunches it. 

#### Application states flow chart

![image-20190321120841914](/images/image-20190321120841914.png)

#### Q. If the app cannot execute any code when in the suspended state, how do chat apps receive push notifications?

These push notifications are generally coming from a web service. These web services push the data to Apple, and Apple then sends us the notification. The code for sending these push nontifications is not in our app.

#### Q. How can we reply directly from the notification then?

Such actions in response to notifications is possible when we have a separate small "app" bundled with our app. This small app generally has a single view controller. When we reply from the notification window, we are basically using this small app, as opposed to our main application. This app has it's own separae application state and transitions. So, our app need not be made active for such actions to be performed. 

#### Q. What does the background app refresh option do?

When background app refresh is enabled, the OS may decide to enable the app to load or refresh it's data for a brief period of time, when the OS is not busy doing other things. So for this brief period, the app may be made active, and then back to inactive and suspended.

> **<u>NOTE:</u>** You can see what applications are in the background or suspended by swiping up and pausing on the Home indicator to get to the task switcher

An application in the suspended state will remain in that state as long as there is adequate system memory. When the OS decides memory is getting low, it will terminate suspended applications as needed. **A suspended application gets no indication that it is about to be terminated. It is simply removed from memory. (An application may remain in the task switcher after it has been terminated, but it will have to relaunch when tapped.)**

## The Application Bundle 

When you build an iOS application project in Xcode, you create an application bundle. The application bundle contains the application executable and any resources you have bundled with your application. Resources are things like storyboard files, images, and audio files – any files that will be used at runtime. When you add a resource file to a project, Xcode is smart enough to realize that it should be bundled with your application. 

How can you tell which files are being bundled with your application? Select the project name from the project navigator. Check out the Build Phases pane in the project target. Everything under Copy Bundle Resources will be added to the application bundle when it is built. 

## Modals and Popovers

For example, when adding a new contact to your phone, you are presented with a screen to fill out the contact's details. We call this kind of presentation a modal presentation as the application is being put into a different mode where a certain set of actions become our focus.

Modally presented view controllers often occupy the entire screen, but in certain contexts they might only take up a
portion of the screen. This is especially true on iPad where there is more space to work with. In either case, the user is expected to interact with the modally presented view controller before proceeding.

#### Alert controllers 

To allow the user to choose a photo source, you will present an alert with the possible choices. Alerts are often used to display information to the user on which they must act. When you want to display an alert, you create an instance of UIAlertController with a preferred style. The two available styles are UIAlertControllerStyle.actionSheet and UIAlertControllerStyle.alert 

##### Presenting programmatically 

```swift
class CalendarViewController: UIViewController {
    func addNewEvent(_ sender: UIBarButtonItem) {
        let viewController = NewCalendarEventViewController()
        present(viewController, animated: true, completion: nil)
    }
}
```

##### Dismissing 

```swift
class CalendarViewController: UIViewController {
    func cancel(_ sender: UIBarButtonItem) {
        dismiss(animated: true, completion: nil)
    }
}
```

![image-20190321113015923](/images/image-20190321113015923.png)

![image-20190321112050259](/images/image-20190321112050259.png)



##### Completion closure 

```swift
dismiss(animated: true, completion: {
    print("View controller finished dismissing!")
})
```



## Permissions 

There are a number of capabilities on iOS that require user approval before use. Here are a subset of those capabilities: 

- Camera and photos 
- Location 
- Microphone 
- HealthKit data 
- Calendar 
- Reminders 

For each of these, your application must supply a usage description that specifies the reason that your application wants to access this information. This description will be presented to the user whenever the application accesses that capability.

#### Caching in the data store

```swift
class ImageStore { 
    let cache = NSCache<NSString,UIImage>()
    func setImage(_ image: UIImage, forKey key: String) {
        cache.setObject(image, forKey: key as NSString)
    }
    func image(forKey key: String) -> UIImage? {
        return cache.object(forKey: key as NSString)
    }
    func deleteImage(forKey key: String) {
        cache.removeObject(forKey: key as NSString)
    }
}
```

Note that the cache is associating an instance of NSString with UIImage. NSString is Objective-C’s version of
String. Due to the way NSCache is implemented (it is an Objective-C class, like most of Apple’s classes that you have been working with), it requires you to use NSString instead of String.

## // MARK: 

As your classes get longer, it can get more difficult to find a method buried in a long list of methods. A good way to organize your methods is to use // MARK: comments. 

Two useful // MARK: comments are the divider and the label: // This is a divider 

// MARK: - 

```swift
// This is a label
// MARK: My Awesome Methods
```

The divider and label can be combined: 

```swift
// MARK: - View life cycle
override func viewDidLoad() { ... }
override func viewWillAppear(_ animated: Bool) { ... }
// MARK: - Actions
func addNewItem(_ sender: UIBarButtonItem) {...}
```

![image-20190321154111660](/images/image-20190321154111660.png)

## Size classes

The relative sizes of screens are defined in *size classes*. A **size class** represents a relative amount of screen space in a given dimension. Each dimension (width and height) can either be compact or regular, so there are four possible combinations of size classes:

![image-20190321154858846](/images/image-20190321154858846.png)

Notice that the size classes cover both screen sizes and orientations. **Instead of thinking about interfaces in terms of orientation or device, it is better to think in terms of size classes.**

#### Modifying Traits for a Specific Size Class 

When editing the interface for a specific size class combination, you are able to change: 

- properties for many views 
- whether a specific subview is installed 
- whether a specific constraint is installed 
- the constant of a constraint 
- the font for subviews that display text 

> **<u>NOTE:</u>** To detect a change in device orientation, we can use `viewWillTransition(to:with:)`. 

#### Varying constraints for different size classes

- To activate constraints on only a particular size classes ,for a partiular trait, you can change things like the axis of the stack view, and it will be applied to only that particular device orientation. We can add size-class-specific options to do this.

- You can also deactivate particular constraints for a particular trait variation (by disabling the install checkbox when in the trait variation). 


## Web Services

#### Building the URL 

Communication with servers is done via requests. A request encapsulates information about the interaction between the application and the server, and its most important piece of information is the destination URL. 

#### Access Control

You can control what can access the properties and methods on your own types. There are five levels of access control that can be applied to types, properties, and methods: 

- open – This is used only for classes, and mostly by framework or third-party library authors. Anything can access this class, property, or method. Additionally, classes marked as open can be subclassed and methods can be overridden outside of the module. 
- public – This is very similar to open; however, classes can only be subclassed and methods can only be overridden inside (not outside of) the module. 
- internal – This is the default. Anything in the current module can access this type, property, or method. For an app, only files within your project can access these. If you write a third-party library, then only files within that third-party library can access them – apps that use your third-party library cannot. 
- fileprivate – Anything in the same source file can see this type, property, or method. 
- private – Anything within the enclosing scope can access this type, property, or method. 

#### Sending the Request

- A URL request encapsulates information about the communication from the application to the server. Most
  importantly, it specifies the URL of the server for the request, but it also has a timeout interval, a cache policy, and other metadata about the request. A request is represented by the URLRequest class. 
- The **URLSession API** is a collection of classes that use a request to communicate with a server in a number of ways. The **URLSessionTask** class is responsible for communicating with a server. The **URLSession** class is responsible for creating tasks that match a given configuration.
- The class that communicates with the web service is an instance of URLSessionTask. There are three kinds of tasks: data tasks, download tasks, and upload tasks. URLSessionDataTask retrieves data from the server and returns it as Data in memory. URLSessionDownloadTask retrieves data from the server and returns it as a file saved to the filesystem. URLSessionUploadTask sends data to the server. 
- Often, you will have a group of requests that have many properties in common. For example, maybe some downloads should never happen over cellular data, or maybe certain requests should be cached differently than others. It can become tedious to configure related requests the same way. 
- This is where URLSession comes in handy. URLSession acts as a factory for URLSessionTask instances. The session is created with a configuration that specifies properties that are common across all of the tasks that it creates. Although many applications might only need to use a single instance of URLSession, having the power and flexibility of multiple sessions is a great tool to have at your disposal. 

- Fetching data from a web service is an asynchronous process: Once the request starts, it may
   take a nontrivial amount of time for a response to come back from the server. Because of this, the fetchInterestingPhotos(completion:) method cannot directly return an instance of PhotosResult. Instead, the caller of this method will supply a completion closure for the PhotoStore to call once the request is complete. 
- This follows the same pattern that URLSessionTask uses with its completion handler: The task is created with a closure for it to call once the web service request completes. Figure 20.6 describes the flow of data with the web service request. 

![image-20190321165226836](/images/image-20190321165226836.png)

#### The Main Thread 

- Modern iOS devices have multicore processors that enable them to run multiple chunks of code simultaneously. A common way to express this is by representing each computation with a different thread of control. 
- When the web service completes, you want it to update the image view. But by default, URLSessionDataTask runs the completion handler on a background thread. You need a way to force code to run on the main thread to update the image view. You can do that easily using the OperationQueue class. 



## Collection Views

#### Creating a UICollectionView 

```swift
let layout = UICollectionViewFlowLayout()
let cv = UICollectionView(frame: frame, collectionViewLayout: layout)
cv.delegate = self
cv.dataSource = self
```

#### UICollectionViewDataSource 

```swift
var photos: [Photos] = ...
func collectionView(_ collectionView: UICollectionView,
        numberOfItemsInSection section: Int) -> Int {
    return photos.count
}
func collectionView(_ collectionView: UICollectionView,
        cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    let identifier = "UICollectionViewCell"
    let cell =
        collectionView.dequeueReusableCell(withReuseIdentifier: identifier,
                                           for: indexPath)
    // Configure the cell
    return cell 
} 
```

#### Customizing a Collection Layout

![image-20190322102944530](/images/image-20190322102944530.png)

![image-20190322103012226](/images/image-20190322103012226.png)

The display of cells is not driven by the collection view itself but by the collection view’s layout. The layout object is responsible for the placement of cells onscreen. Layouts, in turn, are driven by a subclass of UICollectionViewLayout. 

The flow layout that Photorama is currently using is UICollectionViewFlowLayout, which is the only concrete UICollectionViewLayout subclass provided by the UIKit framework. 

Some of the properties you can customize on UICollectionViewFlowLayout are: 

- scrollDirection – Do you want to scroll vertically or horizontally? 
- minimumLineSpacing – What is the minimum spacing between lines? 
- minimumInteritemSpacing – What is the minimum spacing between items in a row (or column, if scrolling horizontally)? 
- itemSize – What is the size of each item? 
- sectionInset – What are the margins used to lay out content for each section?
   
